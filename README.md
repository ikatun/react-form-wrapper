## Synopsis

React Form Wrapper is a higher-order component for wrapping form components and
custom components within your forms.  The API seeks to copy that of an input
element, so you can intuitively compose forms into smaller groups of inputs.

## NOTICE

This library is in it's early stages.  It doesn't currently have many tests and
hasn't been applied to a wide array of use cases.  Use at your own risk.
Help wanted.

## Code Example

```
import React from 'react';
import {render} from 'react-dom';
import FormWrapper from 'react-form-wrapper';

const Profile = FormWrapper()(function ({ getField }) {
  return <div>
    <input placeholder="name" {...getField('name')}/>
    <select {...getField('species')} >
      {['human', 'cat', 'monkey'].map((item, i) =>
      <option key={i} value={item}>{item}</option> )}
    </select>
  </div>
});

const MyForm = FormWrapper()(function ({ onSubmit, onReset, getField }) {
  return <form onSubmit={onSubmit} onReset={onReset}>
    <input {...getField('job.title')} placeholder="job" />
    <Profile {...getField('profile')}/>
    <button type="submit">Submit</button>
    <button type="reset">Reset</button>
  </form>;
}

render(
  <MyForm onSubmit={(data) => console.log(data)}) />,
  document.getElementById('root') );

// result of console.log
// {
//   job: {
//     title: 'string'
//   },
//   profile: {
//     name: 'string',
//     species: 'string'
//   }
// }
```

Two things make React Form Wrapper very easy to use with Redux.
  1) If a form receives an onChange property, it will not attempt to keep state internally
    * an onChange handler will receive the Synthentic event generated by the input event
    * the input name will be a string which represents it's full path
  2) If a form receives a new value, it will update to that new value.

```
import React from 'react';
import MyWrappedForm from './my-wrapped-form';

function MyComponent({ onChange, onSubmit, value }) {
  return <MyWrappedForm {...{ onChange, onSubmit, value }} />
}

function mapStateToProps(state) {
  return {
    value: state.path.to.my.form };
}

const mapDispatchToProps = {
  onChange: (event) => ({type: 'MY_WRAPPED_FORM_CHANGE', event}),
  onSubmit: (event) => ({type: 'MY_WRAPPED_FORM_SUBMIT', event})
}

export default connect(mapStateToProps, mapDispatchToProps)(MyComponent);
```

## Motivation

The aim of this package is to be/have:
*  Easy to use without having to declare a schema
*  Performant (immutable.js and pure-render-mixin used internally)
*  Use with or without Redux
*  Data management only, no custom components
*  JSON schema support (future version)
*  Forms composed of other forms
*  Intuitive API, predictable behavior

## Installation

npm install --save react-form-wrapper

## API Reference

Form Wrapper propTypes:
* name
  * path (string) to value inside of the top-most value
* value
  * scope of value should match name
* delimiter
  * delimiter used in name, defaults to '.'
* onSubmit
  * if onChange also passed as prop, onSubmit will return the submit event
  * if onChange not passed as prop, onSubmit will return a JS object for the data
* onReset
  * resets the form's value to the most recently received value prop
* onChange
  * handler for input change events

Props passed to wrapped component:
  * value - value maintained in state or received by form wrapper (for child forms)
  * onSubmit & onReset
    * pass to form element
  * onChange
  * getName(name)
    * appends name to name of parent form wrapper to get full path
  * getValue(name)
    * get value of name/path within the value received by parent form-wrapper
    * also looks out for undefined
  * getField
    * convenience function that bundles the onChange, value(from getValue), and name(from getName)


To help clarify how nested forms work, let's rewrite the example above without using 'getField'.

```
const Profile = FormWrapper()(function ({ getValue, getName, onChange }) {
  return <div>
    <input
      placeholder="name"
      name={getName('name')}
      onChange={onChange}
      value={getValue('name')} />

    <select
      name={getName('species')}
      onChange={onChange}
      value={getValue('species')} >

      {['human', 'cat', 'monkey'].map((item, i) =>
      <option key={i} value={item}>{item}</option> )}

    </select>
  </div>
});

const MyForm = FormWrapper()(function ({ onSubmit, onReset, onChange, getValue, getName }) {
  return <form onSubmit={onSubmit} onReset={onReset}>
    <input
      placeholder="job"
      name={getName('job.title')}
      value={getValue('job.title')}
      onChange={onChange}/>

    <Profile
      name={getName('profile')}
      value={getValue('profile')}
      onChange={onChange} />

    <button type="submit">Submit</button>
    <button type="reset">Reset</button>
  </form>;
}
```

Profile isn't maintaining any state, just forwarding all changes to MyForm.  Before
MyForm's onChange handler receives the event, which, in the name property,
has the full path of where to update the value. Since the value in MyForm is an immutable.js object,
updates are easily done using the path, using the 'updateIn' method.

Using getValue inside of Profile will access the value that is passed to profile.
If you type in the job.title input field, Profile will not re-render, because it's value
isn't changing.

Because the values are immutable.js objects, and can sometimes be undefined, using the 'getValue'
method that React Form Wrapper provides is a convenient way to access the value.

getValue and getField accept a second parameter, an object of options, to which you can pass toJS: true.
This will get you the JS value and not the immutable.js equivalent.

Better documentation to come.


### TODO
  * testing
  * documentation
  * validation
  * JSON Schema support

## Contributors

If you would like to contribute, please first open a new issue for discussing.
